


### CRTP1

最简单的实现了CRTP
中心思想是：使用模版生成基类来让子类继承
为了实现模版的基类对子类函数的调用，需要模版基类中得到子类的信息，所以继承时候要传入子类

具体不同:

- 基类
    由虚类变为了模版类
- 全局虚函数
    由全局函数变为了模版函数
- 子类函数调用
    由虚函数表的指针变为了this指针的强转



### CRTP2

上面还存在一些问题：
 1. 纯虚函数没有实现
    如果子类没有实现func，而基类强转之后直接进行调用，调用回基类函数无限递归
 2. 析构函数不能正确使用
    Base<Derived> 与 Derived 之间没有虚继承关系，所以用基类指针释放时候调用不到子类

所以有了一些解决办法:
1.纯虚函数使用impl后缀的函数来实现具体内容，并且在基类中有一个默认版本，就不会出现问题。
或者纯虚函数还是使用纯虚函数来实现。
2.既然没有正常的调用到子类析构函数，那么就显示的声明destroy并调用来实现子类的析构
或者使用虚函数实现析构函数。
3.强转的地方可以放在一个函数来统一实现。



### CRTP3

是保持了纯虚函数和虚析构函数的一种

还是存在一些问题的：
CRTP是为了避免虚函数的效率问题而实现的
暂时还没有确定虚函数效率问题是哪？
1.虚表查找么？
2.虚表跳转打乱指令流水线么？
3.虚表跳转不好预测么？
4.cache miss导致么？

既然要抽象层的纯虚函数，就已经没办法避免效率问题，所以既然用CRTP提升效率就最好避免虚函数的出现



### CRTP4

还有一种可能是子类继承的时候传的是另一个子类的名字，也是不正常的问题，
但是这种问题只有在显式调用的时候才能报错
为了让它暴露在编译阶段，所以要将基类中本应该作为protected的成员(为了继承给子类用)变为
private(声明子类为友元类的方式达到子类访问的目的)这样的话
子类D1 继承自基类Base<D>，而其中基类的友元类为D，所以当D1操作基类的私有变量时就会产生错误



### CRTP_DEMO

简单的一个demo 以及 标注出从虚继承体系改过来的时候要注意的不同点


